<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Glittergalaxy</title>
    <description>private blog
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 20 Nov 2017 15:14:14 +0800</pubDate>
    <lastBuildDate>Mon, 20 Nov 2017 15:14:14 +0800</lastBuildDate>
    <generator>Jekyll v3.5.1</generator>
    
      <item>
        <title>补充html5基础知识</title>
        <description>&lt;p&gt;补充html5基础知识&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;meta对象
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- content  'telephone=no','text/html;charset=gb2312','width=device-width;maximum-scale=1.0;user-scale=1.0;'
- name 'format-detection','viewport'
- httpEquiv 'charset','expires','set-cookie','Content-Type',
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;html5新属性
    &lt;ul&gt;
      &lt;li&gt;video [controls,autoplay,width,height,loop,src,preload] ogg文件适用于firefox、opera、chrome,safari文件必须是peg4类型。&lt;/li&gt;
      &lt;li&gt;audio [controls,autoplay,loop,src,preload]&lt;/li&gt;
      &lt;li&gt;drag drop 任何元素都可以拖放&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;img ondragstart=drap(event) draggable=&quot;true&quot; id=&quot;drag1&quot;/&amp;gt;
 &amp;lt;div ondrop=&quot;drop(event)&quot; ondropover=&quot;allowDrop(event)&quot; id=&quot;drop1&quot;&amp;gt;&amp;lt;/div&amp;gt;

 function drap(ev){
     ev.preventDefault();
     ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id) 
 }

 function allowDrop(ev){
     ev.preventDefault();
 }

 function drop(ev){
     ev.preventDefault();
     var data = ev.dataTransfer.getData(&quot;Text&quot;);
     ev.target.appendChild(document.getElementById(data));
 }

 拖动开始：ondragstart,触发后设置被拖动数据类型和值
 event.dataTransfer.setData(&quot;Text&quot;,ev.target.id);

 拖动到某一位置：ondragover,默认元素不可拖动，此时需阻止默认处理方法event.preventDefault();  

 拖动结束：ondrop,触发后获取到被拖动元素
 var data = event.dataTransfer.getData(&quot;Text&quot;);
 event.target.appendChild(document.getElementById(data));
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;canvas [width,height]  - svg&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  1. 获取到canvas，创建context对象
  var c = document.getElementById(&quot;canvas&quot;);
  var ctx = c.getContext(&quot;2d&quot;);

  2. 绘制线条
  ctx.moveTo(10,10);//移动到某一个点
  ctx.lineTo(150,50);//线条画到某一点
  ctx.stroke();//填充

  3. 绘制圆形
  ctx.fillStyle=&quot;#000&quot;;//填色
  ctx.beginPath();//开始
  ctx.arc(x,y,r,startAngle,endAngle,顺时针或逆时针);//画圆
  ctx.closePath();//结束
  ctx.fill();//填充

  4. 渐变
  var rect = ctx.createLinearGradient(0,0,175,50);//矩形区域
  rect.addColorStop(0,&quot;#fff&quot;);
  rect.addColorStop(1,&quot;#000&quot;);//渐变色
  ctx.fillStyle = rect;//设置渐变色为填充颜色
  ctx.fillRect(0,0,175,50);//画矩形  

  5. 图像
  var img = new Image();
  img.src = &quot;flower.png&quot;;//创建img对象并设置其属性
  ctx.drawImage(img,0,0);//画出图像

  canvas与svg比较
  1.依赖分辨率、不依赖
  2.不支持事件处理器、支持事件处理器
  3.弱的文本渲染能力、最适合带有大型渲染程序的应用程序，比如谷歌地图
  4.适合图像密集型游戏，其中的许多对象会被频繁重绘、不适合游戏应用
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Geolocation API 定位&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  if(navigator.geolocation){
      navigator.geolocation.getCurrentPosition(showPosition,showError);
  }

  function showPosition(position){
      x.innerHTML = &quot;latitude&quot;+position.coords.latitude+&quot;longtitude&quot;+position.coords.longtitude;
        
  }

  function showError(error){
      switch(error.code){
          case error.PERMISSION_DENIED:
              return &quot;user denied&quot;
              break;
          case error.POSITION_UNAVAILABLE:
              return &quot;location unavailable&quot;
              break;
          case error.TIMEOUT:
              return &quot;timeout&quot;
              break;
          case error.UNKNOW_ERROR:
              return &quot;unknow error&quot;
              break;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;localStorage sessionStorage 客户端存储数据&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  1. localStorage
  无时间限制
  2. sessionStorage
  针对一个session的数据存储，当用户关闭浏览器窗口后数据被删除。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;应用缓存 application cache 除了IE不支持&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 20 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/html5-base/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/html5-base/</guid>
        
        <category>css</category>
        
        <category>html5</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>左右布局</title>
        <description>&lt;p&gt;左边固定宽度，右边自适应布局的实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.wrapper{
    height:800px;
    width:100%;
}
.left{
    width:200px;
}
.right{
    height:100%;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;float方法或绝对定位方法
    &lt;ul&gt;
      &lt;li&gt;左边元素 float:left;或 position:absolute;&lt;/li&gt;
      &lt;li&gt;右边元素 margin-left:200px;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;flex布局
    &lt;ul&gt;
      &lt;li&gt;父元素 display:flex;&lt;/li&gt;
      &lt;li&gt;右边 flex:1;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;table布局
    &lt;ul&gt;
      &lt;li&gt;父元素 display:table;&lt;/li&gt;
      &lt;li&gt;左边、右边 display:table-cell;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;display:table-cell可实现以下功能
    &lt;ul&gt;
      &lt;li&gt;不定高元素垂直居中&lt;/li&gt;
      &lt;li&gt;等高实现&lt;/li&gt;
      &lt;li&gt;左侧定宽，右侧自适应布局&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 17 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/layout-css/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/layout-css/</guid>
        
        <category>css</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>移动端适配方案</title>
        <description>&lt;p&gt;移动端适配方案实现方式&lt;/p&gt;

&lt;h4 id=&quot;移动端适配&quot;&gt;移动端适配&lt;/h4&gt;

&lt;p&gt;一、 基于flexible插件的自适应&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;获取dpr,若已存在则使用当前dpr&lt;br /&gt;
 dpr即 window.devicePixelRatio,dpr返回当前显示设备的物理像素分辨率与CSS像素分辨率的比率。简单来说，这告诉浏览器应该使用多少个屏幕的实际像素来绘制一个CSS像素。&lt;/li&gt;
  &lt;li&gt;设置viewport中的scale = 1/dpr
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scale=no&quot; /&gt;
  &lt;/li&gt;
  &lt;li&gt;根据deviceWidth以及dpr计算并设置rem大小&lt;br /&gt;
 deviceWidth/dpr&amp;gt;540按照540计算，rem = deviceWidth*dpr/10，设计图分成10等分每一等分为rem的单位大小;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;二、 基于vw的自适应&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;vw浏览器支持&lt;br /&gt;
CSS3新加属性，chrome/firefox/IE9+支持。android browser4.4+支持，chrome for android39支持。1vw等于视窗高度的1%。视窗高度指window.innerHeight包含了底部滚动条高度（如果有的话）&lt;/li&gt;
  &lt;li&gt;其余相关属性&lt;br /&gt;
vh:viewport height
vmin:vw 和vh中较小的那个。&lt;/li&gt;
  &lt;li&gt;postcss插件&lt;br /&gt;
根据vw计算原理，如果是ipone6,1vw=7.5px。那么我们在写css时只需以vw为单位写样式。利用postcss-px-to-viewport,书写样式时以px为单位，插件会编译自动计算其对应的vw值。相当于浏览器自己提供了一套适应性解决方案，和flexible原理相同，但是由于计算误差，可能会存在问题。&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Thu, 16 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/mobile-flexible/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/mobile-flexible/</guid>
        
        <category>mobile</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>vue消息组件</title>
        <description>&lt;p&gt;vue实现消息组件&lt;/p&gt;

&lt;h4 id=&quot;1-组件之间传递信息的方法&quot;&gt;1. 组件之间传递信息的方法&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;vuex 所有组件之间都可以传递&lt;/li&gt;
  &lt;li&gt;props 父子组件传递信息&lt;/li&gt;
  &lt;li&gt;$parent 父子组件传递信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-基于props书写组件&quot;&gt;2. 基于props书写组件&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 父组件

&amp;lt;message :type=&quot;msg.type&quot; :show=&quot;msg.show&quot; :msg=&quot;msg.msg&quot;  @visible-change=&quot;modalVisibleChange&quot;&amp;gt;&amp;lt;/message&amp;gt;
//绑定方法
export default {
    data(){
        return {
            msg:{
                type:'loading',
                show:true,
                msg:'加载中'
            }
        }
    },
    methods:{
        //set message box show/type/content/showtime
        modalVisibleChange(val,msg,type,time){
            this.msg.show = val;
            if(msg){
                this.msg.msg = msg;
            }
            if(type){
                this.msg.type = type;
            }
            if(time){
                setTimeout(() =&amp;gt; {
                    this.msg.show = false;
                },time);
            }
        }
    }
}

- 子组件

&amp;lt;template&amp;gt;
    &amp;lt;div v-if=&quot;show&quot; class=&quot;message&quot; transition=&quot;fade&quot;&amp;gt;
        &amp;lt;div class=&quot;icons-box tcenter&quot;&amp;gt;
            &amp;lt;img src=&quot;../assets/success.png&quot; v-if=&quot;type=='success'&quot;&amp;gt;
            &amp;lt;img src=&quot;../assets/success.png&quot; v-if=&quot;type=='fail'&quot;&amp;gt;
            &amp;lt;img src=&quot;../assets/error.png&quot; v-if=&quot;type=='error'&quot;&amp;gt;
            &amp;lt;img src=&quot;../assets/loading.png&quot; v-if=&quot;type=='loading'&quot; class=&quot;loading&quot;&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;tcenter&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

export default {
    name:'message',
    props:['type','msg','show'],
    watch:{
        show:function(val){
            if(val &amp;amp;&amp;amp; this.type!='loading'){
                setTimeout(() =&amp;gt;{
                    this.$emit(&quot;visible-change&quot;,false);
                },3000)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;3-原理&quot;&gt;3. 原理&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;子组件通过props获取父组件的属性，通过$emit方法触发父组件定义的方法，父组件在响应方法中修改属性的show/type等的值。&lt;/li&gt;
  &lt;li&gt;当父组件需要显示消息组件时，将show/type/msg等属性内容传递给子组件，当用户手动点击关闭子组件时，子组件利用$emit触发父组件对应的方法修改响应的show/type/msg属性并通过props传递给子组件。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 06 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/vue-message-component/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/vue-message-component/</guid>
        
        <category>vue</category>
        
        <category>component</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>美化range元素</title>
        <description>&lt;p&gt;HTML5原生range元素在不同浏览器中的样式不一样且不太美观，因此有两种方式实现较美观的range。一种是美化原生range元素，另一种则是自己实现一个range组件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    /*range panel*/
    .slider{
        margin:0 2.6rem;
        height:100%;
    }
    .slider&amp;gt;input[type='range']{
        width:100%;
        height: 0.3rem;
        height:3.2rem\0;
        border-radius: 0.3rem; /*将轨道设为圆角的*/
        background: -webkit-linear-gradient(left,#f6a128, #f6a128) no-repeat #e1e1e1;
        background-size:50% 100%;
    }
    input[type=range] {
        -moz-appearance: none;
        -webkit-appearance: none;  
        padding:0;
        border:0;
        position:relative;
        top:-.3rem;
    }
    input[type=range]::-webkit-slider-thumb {
        -webkit-appearance: none;
        height: 2rem;
        width: 2rem;
        margin-top: -.4rem; 
        background: #ffffff; 
        border-radius: 50%;
        border: solid 1px #e1e1e1; 
        box-shadow: 0 2px 2px 0 rgba(0,0,0,0.10), 0 3px 3px 0 rgba(0,0,0,0.05);
    }

    /*moz*/
    input[type=range]::-moz-range-track {
        height: 0.3rem;
        border-radius: 0.3rem; 
    }
    input[type=range]::-moz-range-thumb {
        -webkit-appearance: none;
        height: 2rem;
        width: 2rem;
        margin-top: -.4rem; 
        background: #ffffff; 
        border-radius: 50%;
        border: solid 1px #e1e1e1; 
        box-shadow: 0 2px 2px 0 rgba(0,0,0,0.10), 0 3px 3px 0 rgba(0,0,0,0.05);
    }
    input[type=range]::-moz-range-progress {
        background:linear-gradient(#f6a128, #f6a128) no-repeat;
        height: 0.3rem;    
        border-radius: 0.3rem;
    }

    /*IE*/
    input[type=range]::-ms-track {
        border-color: transparent;
        color: transparent;
        height:.3rem;
        border-radius:.3rem; 
    }

    input[type=range]::-ms-thumb {
        height: 2rem;
        width: 2rem;
        margin-top: -.35rem; 
        background: #ffffff; 
        border-radius: 50%; 
        border: solid 1px #e1e1e1;
        box-shadow: 0 2px 2px 0 rgba(0,0,0,0.10), 0 3px 3px 0 rgba(0,0,0,0.05); 
    }

    input[type=range]::-ms-fill-lower {
        height: .3rem;
        border-radius: .3rem;
        background: linear-gradient(#f6a128, #f6a128) no-repeat;
    }

    input[type=range]::-ms-fill-upper {
        height: .3rem;
        border-radius: .3rem;
        background: #e1e1e1;
    }
    /*range panel end*/

    为兼容webkit
    需要配合js设置backgroundSize
    var points = document.getElementById(&quot;points&quot;);
    var value = points.value*10;
    points.style.backgroundSize = value+'% 100%';
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 06 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/posts/range/</link>
        <guid isPermaLink="true">http://localhost:4000/posts/range/</guid>
        
        <category>html5</category>
        
        
        <category>posts</category>
        
      </item>
    
  </channel>
</rss>
