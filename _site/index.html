<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title> Glittergalaxy</title><meta name="description" content="private blog "><link rel="canonical" href="http://localhost:4000/"><link rel="alternate" type="application/rss+xml" title="Glittergalaxy" href="http://localhost:4000/feed.xml"><link href='https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|Roboto+Condensed:700&subset=latin' rel='stylesheet' type='text/css'><link rel="stylesheet" href="/assets/css/main.css"><meta property="og:url" content="http://localhost:4000/"><meta property="og:type" content="website"><meta property="og:title" content="Glittergalaxy"><meta property="og:description" content="little thing"><meta property="og:site_name" content="Glittergalaxy"><meta name="twitter:card" content="summary"><meta name="twitter:url" content="http://localhost:4000/"><meta name="twitter:title" content="Glittergalaxy"><meta name="twitter:description" content="little thing"><meta property="og:image" content="http://localhost:4000/assets/images/galaxy.jpg"><meta name="twitter:image" content="http://localhost:4000/assets/images/galaxy.jpg"><body><div id="shadow"></div><header class="main-header content-wrapper"> <input type="checkbox" id="menu-checkbox" /><nav class="center-wrapper nav-main"> <a class="blog-logo" href="/">Glittergalaxy</a> <a href="/about/">About</a> <a href="/posts/">Articles</a>  <label for="menu-checkbox" class="toggle-button" data-open="☰" data-close="☰" onclick></label></nav></header><aside class="sidebar" role="note" style="background-image: url(http://localhost:4000/assets/images/galaxy.jpg)"><div class="cover"><div class="cover-text"><div class="heading"> Glittergalaxy</div><p> little thing</div></div><div id="switcher"></div></aside><main class="content-wrapper"><article class="index-page"><h2><a href="/posts/array-object/">数组以及对象方法总结</a></h2><p>数组以及对象的常用方法<h4 id="一-数组">一、 数组</h4><ol><li>Array.prototype.forEach() 按升序为数组中每个元素执行一次提供的函数。<div class="highlighter-rouge"><pre class="highlight"><code>arr.forEach(callback(currentValue,index,array){
 //函数接收三个参数，thisArg可选，当执行时用作this的值    
}，thisArg)
</code></pre></div><p>notice:无法中止或跳出forEach循环，除非抛出一个异常，不可链式调用。如果使用箭头函数表达式传入函数参数，thisArg会被忽略，因为箭头函数在词法上版定了this值。<li>Array.prototype.map() 创建一个新数组，其结果是该数组中每个元素都调用一个提供的函数后的结果。<div class="highlighter-rouge"><pre class="highlight"><code>let numbers = [1,5,10,15];
let doubles = numbers.map(x =&gt; x**2);
//doubles is now [1,25,100,225]
let new_array = arr.map(function callback(currentValue,index,array){
 return element for new_array;
},thisArg)
</code></pre></div><li>Array.prototype.filter() 创建一个新数组，其包含通过所提供函数实现的测试的所有元素。<div class="highlighter-rouge"><pre class="highlight"><code>function isBigEnough(value){
 return value &gt;= 10;
}
var filtered = [12,5,3,129,44].filter(isBigEnough);
//filterd is [12,129,44];
var new_array = arr.filter(callback(currentValue,index,array),thisArg);
</code></pre></div><li>Array.prototype.includes() 用来判断一个数组是否包含一个指定的值，返回true或false<div class="highlighter-rouge"><pre class="highlight"><code>arr.includes(searchElement,fromIndex)
</code></pre></div><li>Array,prototype.some() | Array,prototype.every() | Array.prototype.find() 测试数组中的某些元素是否通过提供的函数的测试,返回bool<div class="highlighter-rouge"><pre class="highlight"><code>const isBigEnough = (element,index,array) =&gt; {
 return element &gt; 10;
}
arr.some(callback,thisArg)
var passed = [12,5,8,1,4].some(isBigEnough);
// passed is true
var passed = [12,5,8,1,4].every(isBigEnough);
// passed is false
如果找到一个符合条件的值，some返回true。
如果找到一个不符合条件的值，every返回false。
如果找到一个符合条件的值，find返回该值。
如果找到一个符合条件的值，findIndex返回该索引。
</code></pre></div><li>Array,prototype.reduce() 对累加器和数组中的元素，从左至右应用一个函数<div class="highlighter-rouge"><pre class="highlight"><code>arr.reduce(callback,initialValue);
//四个参数，第一个参数表示列加气累加回调的返回值，他是上一次调用回调时返回的累计值，或initialValue
callback(accumulator,currentValue,currentIndex,array);
initialValue用作第一个调用callback的accumulator的值，如果没有提供初始值，则将使用第一个元素，在没有初始值的空数组上调用reduce将报错。
</code></pre></div><li>Array.prototype.copyWithin() 复制数组的一部分到同数组的另一位置<div class="highlighter-rouge"><pre class="highlight"><code>arr.copyyWithin(target,start,end);
target表示索引，复制序列到该位置，如果为负数，从末尾开始计算，大于等于arr.length,将不会发生拷贝
如果end被忽略，copyWithin将会复制到arr.length;
</code></pre></div><li>Array.prototype.toLocaleString() 数组中的元素使用各自的toLocaleString方法转成字符串，这些字符串使用一个特定语言环境的字符串（“，”）隔开<li>Array.from() 想要转换成数组的为伪数组对象或可迭代对象。 与map不同之处在于可以对伪数组对象或刻碟带对象进行转换。<div class="highlighter-rouge"><pre class="highlight"><code>Array.from(arraylike,mapFn,thisArg)
</code></pre></div><li>Array.observe(arr,callback) 每次arr发生任何变化时，回调函数将被调用，调用参数为所有变化按发生顺序组成的数组。 ``` callback 每当数组发生变化时，使用如下参数调用该函数：<ul><li>changes 用于表示变化的对象数组。每个变化对象的属性如下： name: 变化的属性名。 object: 变化后的数组。 type: 用于表示变化类型的字符串。其取值为”add”、”update”、”delete”或 “splice”之一。 oldValue: 仅用于”update”和”delete”类型。变化之前的取值。 index: 仅用于”splice”类型。变化发生所在索引。 removed: 仅用于”splice”类型。被删除元素组成的数组。 addedCount: 仅用于”splice”类型。被添加的元素数量。</ul><p>通过Array方法如 Array.prototype.pop( ) 触发的变化将被报告成”splice”变化，长度不变但索引赋值发生变化的将被报告成”update”变化。<p>var arr = [‘a’, ‘b’, ‘c’];</ol></article><article class="index-page"><h2><a href="/posts/promise-async/">异步请求方法</a></h2><p>由vue项目看常用异步请求方法语法以及ES6异步请求方法<h4 id="一promise">一、Promise</h4><ol><li>Promise对象是一个构造函数，用来生成Promise实例,接受一个函数作为参数，而该函数的两个参数分别是resolve和reject。他们是两个函数，由js引擎提供，不用自己部署。<div class="highlighter-rouge"><pre class="highlight"><code>const promise = new Promise(function(resolve,reject){
 if(){
     resolve(value);
 }else{
     reject(error);
 }
})
</code></pre></div><li>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。<li>如果调用resolve和reject函数时带有参数，那么他们的参数会被传递给回调函数。<li>resolve函数的参数除了是正常的值以外，还可能是另一个Promise实例,<div class="highlighter-rouge"><pre class="highlight"><code>const p1 = new Promise(function(resolve,reject){
// ... 
});
const p2 = new Promise(function(resolve,reject){
 // ...
 resolve(p1);
})
</code></pre></div><li>上面代码中，p1和p2都是Promise实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。 注意，这里p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态，如果p1的状态是pending,那么p2的回调函数就会等待p1的状态改变。<li>Promise实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。他的作用式微Promise实例添加状态改变时的回调函数。then方法的第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数。then方法返回的是一个新的Promise实例，因此可以采用链式写法，即then方法后面再调用另一个then方法。<div class="highlighter-rouge"><pre class="highlight"><code>getJSON("/post.json").then(function(json){
 return json.post;
}).then(function(post){
 //...
})
</code></pre></div><p>上面的代码使用then方法，依次指定了两个回调函数，第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。第一个then方法指定的回调函数，返回的是另一个promise对象，这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化再调用相应方法。<li>catch方法是.then(null,rejection)的别名，用于指定发生错误时的回调函数。一般来说，不要在then方法中定义reject状态的回调函数（即then的第二个参数），总是使用catch方法。理由是catch方法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不是用then 方法中的第二个参数。<div class="highlighter-rouge"><pre class="highlight"><code>promise.then(function(data){
 // success
}).catch(function(data){
 // error
})
</code></pre></div><h4 id="二fetch">二、fetch</h4><li>浏览器兼容：firefox 39以上，chrome42以上<li>原理：基于Promise实现，无论如何，都会返回一个promise实例<li>当接收到一个代表错误的http状态码时，从fetch()返回的Promise不会被标记为reject,及时状态码是404或500，相反她会将promise状态标记为resolve，仅当网络故障或请求被阻止时，才会标记为reject。<li>默认情况下,fetch不会从服务端发送或接受任何cookies,如果站点依赖于用户session,则会导致未经认证的请求。（要发送cookies,必须设置credentials选项）<li>fetch用法以及相关api ``` if (window.fetch) { let myInit = { credentials: ‘include’,//设置发送请求时自动发送cookies method: type, headers: { ‘Accept’: ‘application/json’, ‘Content-Type’: ‘application/json’ },//对象或包含 ByteString 值的对象字面量。 mode: “cors”,// 可选值为cors/no-cors/same-origin cache: “force-cache”//强制缓存 }</ol></article><article class="index-page"><h2><a href="/posts/html5-base/">补充html5基础知识</a></h2><p>补充html5基础知识</article><article class="index-page"><h2><a href="/posts/layout-css/">左右布局</a></h2><p>左边固定宽度，右边自适应布局的实现</article><article class="index-page"><h2><a href="/posts/mobile-flexible/">移动端适配方案</a></h2><p>移动端适配方案实现方式</article></main><footer class="blog-footer content-wrapper"><p>&copy; <span class="full-year"></span> Glittergalaxy</footer><script src="/assets/js/scripts.js"></script>
